/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50553
Source Host           : localhost:3306
Source Database       : test

Target Server Type    : MYSQL
Target Server Version : 50553
File Encoding         : 65001

Date: 2019-02-21 11:51:56
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for de_department
-- ----------------------------
DROP TABLE IF EXISTS `de_department`;
CREATE TABLE `de_department` (
  `id` smallint(5) NOT NULL AUTO_INCREMENT COMMENT '部门的编号',
  `depart_name` varchar(30) NOT NULL COMMENT '部门名称',
  `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态1启用2禁用',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of de_department
-- ----------------------------

-- ----------------------------
-- Table structure for tp_article
-- ----------------------------
DROP TABLE IF EXISTS `tp_article`;
CREATE TABLE `tp_article` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT '',
  `author` varchar(255) DEFAULT 'CarryOnHxy',
  `timestamp` bigint(20) DEFAULT NULL,
  `comment_num` int(11) DEFAULT '0',
  `coverUrl` varchar(255) DEFAULT 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg',
  `like_num` int(11) DEFAULT '0',
  `detail` longtext,
  `categrory_id` tinyint(3) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `categrory` (`categrory_id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_article
-- ----------------------------
INSERT INTO `tp_article` VALUES ('2', '使用 vue-lazyload 进行图片懒加载', 'CarryOnHxy', '1550305897000', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', ' <h2><strong>使用 vue-lazyload 进行图片懒加载</strong></h2><p><a href=\"http://www.ptbird.cn/vue-lazyload-img-lazy-load.html#comments\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">评论：1</a>&nbsp;<em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;<a href=\"http://www.ptbird.cn/vue-lazyload-img-lazy-load.html\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">阅读：5284</a><em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;喜欢：1</p><h2>一、需求</h2><p>对某个大列表的图片需要进行懒加载，直接使用了 vue 的第三方插件&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">vue-lazyload</code>，（这好像是用的最多的插件，也的确很好用）</p><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">vue-lazyload</code>&nbsp;github地址：</p><ul><li><a href=\"https://github.com/hilongjw/vue-lazyload\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://github.com/hilongjw/vue-lazyload</a></li></ul><p>在线demo地址：</p><ul><li><a href=\"https://hilongjw.github.io/vue-lazyload/\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://hilongjw.github.io/vue-lazyload/</a></li></ul><h2>二、基本使用</h2><h3>安装：</h3><pre class=\"ql-syntax\" spellcheck=\"false\">yarn add vue-lazyload\n\n</pre><h3>引入</h3><pre class=\"ql-syntax\" spellcheck=\"false\">import VueLazyload from \'vue-lazyload\'\n\n</pre><h3>Vue.use</h3><p>vue 在 use 的时候，存在配置项目，主要配置如下：</p><ul><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">preLoad</code>: 图片加载的高度范围比例，默认为1.3，数字越大，预加载图片越多，数字越小，预加载图片数量越少</li><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">error</code>: 加载错误的代替图片（使用 require 直接引入 src 中的图片）</li><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">loading</code>: 加载时的 loading 图片（使用 require 直接引入 src 中的图片）</li><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">attempt</code>: 尝试加载的次数 默认为3</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">const lazyloadOptions = {\n    preLoad: 1.3,\n    error: require(\"@/assets/images/error.png\"),\n    loading: require(\"@/assets/images/loading.gif\"),\n    attempt: 1\n};\nVue.use(VueLazyload,options);\n\n</pre><h3>在 template 中使用</h3><p>如果是写在 template 的模板代码，可以直接使用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">v-lazy</code>&nbsp;指定图片地址，如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;img v-lazy=\"item.imgurl\" :alt=\"item.creator.name\" width=\"50\" height=\"50\"&gt;\n\n</pre><p>如果是在普通的 html 代码中使用，则需要指定一个&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">v-lazy-container</code>&nbsp;的属性，并且指定选择器是什么：</p><p>(用的比较少)</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div v-lazy-container=\"{ selector: \'img\' }\"&gt;\n  &lt;img data-src=\"//domain.com/img1.jpg\"&gt;\n  &lt;img data-src=\"//domain.com/img2.jpg\"&gt;\n  &lt;img data-src=\"//domain.com/img3.jpg\"&gt;  \n&lt;/div&gt;\n\n</pre><h2>三、其他的一些经常用的配置项</h2><ul><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">listenEvents</code>&nbsp;：希望 vue 监听的事件，默认值：<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">[\'scroll\', \'wheel\', \'mousewheel\', \'resize\', \'animationend\', \'transitionend\', \'touchmove\']</code></li><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">filter</code>：图片类型的过滤,可以做到动态的修改图片的 src</li><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">lazyComponent</code>:是否使用懒加载组件</li></ul><p>使用内置的懒加载组件，能够做更多额外的工作，比如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;lazy-component @show=\"handler\"&gt;\n  &lt;img class=\"mini-cover\" :src=\"img.src\" width=\"100%\" height=\"400\"&gt;\n&lt;/lazy-component&gt;\n&lt;script&gt;\n  {\n    ...\n    methods: {\n      handler (component) {\n        console.log(\'this component is showing\')\n      }\n    }\n\n  }\n&lt;/script&gt;\n\n</pre><ul><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">observer</code>:是否使用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">IntersectionObserver</code></li></ul><p>这个API兼容性非常差现在，可以参考:</p><ul><li><a href=\"http://www.ptbird.cn/intersectionObserver-scroll-animation.html\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">IntersectionObserver 实现滚动侦测动画</a></li></ul><p><br></p>', '1');
INSERT INTO `tp_article` VALUES ('3', 'Win声音问题', 'CarryOnHxy', '1550305897000', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', ' <h2><strong>win10更新后台式机前排插孔没有声音</strong></h2><p><a href=\"http://www.ptbird.cn/win10-update-no-vocie-front.html#comments\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">评论：0</a>&nbsp;<em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;<a href=\"http://www.ptbird.cn/win10-update-no-vocie-front.html\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">阅读：650</a><em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;喜欢：1</p><ul><li><a href=\"http://www.ptbird.cn/win10-update-no-vocie-front.html#menu_index_1\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">一、问题</a></li><li><a href=\"http://www.ptbird.cn/win10-update-no-vocie-front.html#menu_index_2\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">二、解决办法</a></li><li><a href=\"http://www.ptbird.cn/win10-update-no-vocie-front.html#menu_index_3\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">三、找不到 Reltek</a></li><li><a href=\"http://www.ptbird.cn/win10-update-no-vocie-front.html#menu_index_4\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">四、如果耳麦没声音</a></li></ul><blockquote>玄学问题，搞了好久</blockquote><h2>一、问题</h2><blockquote>保证耳机没有问题</blockquote><p>昨天一台 win10 专业版的电脑强制更新（强烈吐槽这种行为）之后，第二天开机没有声音了。</p><p>电脑情况：</p><ul><li>台式机</li><li>前排二级插孔</li><li>驱动没发现任何问题</li></ul><h2>二、解决办法</h2><p>打开<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">控制面板</code>（可以直接运行命令&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">control</code>），然后选择硬件和声音，</p><p>选择&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">Realtek高清晰音频管理器</code></p><p><img src=\"http://static.ptbird.cn/usr/uploads/2018/07/2175907585.png\" alt=\"TIM截图20180728145246.png\"></p><p>打开后，点击右上角<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">设置</code>或者是<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">文件夹</code>图标</p><p><img src=\"http://static.ptbird.cn/usr/uploads/2018/07/163428765.png\" alt=\"2.png\"></p><p>选中&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">禁用前排面板插孔检测</code>即可。</p><p><img src=\"http://static.ptbird.cn/usr/uploads/2018/07/569043907.png\" alt=\"1.png\"></p><h2>三、找不到 Reltek</h2><p>没有 Reltek 的话使用 驱动精灵 安装一个驱动，重启之后就有了。</p><h2>四、如果耳麦没声音</h2><p>弄好之后，发现我的麦克风也没问题，而我的麦克风是好用的。</p><p>检查一下【设置】 - 【声音】 - 【麦克风】 - 【允许应用程序访问麦克风】</p><blockquote>不是很懂为什么更新之后，会将麦克风的访问默认关掉！</blockquote><h2><br></h2>', '6');
INSERT INTO `tp_article` VALUES ('5', 'Canvas常用API及使用流程', 'CarryOnHxy', '1550455218900', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>Canvas常用API及使用流程</em></h1><p>&nbsp;&nbsp;<img src=\"//:0\" height=\"114\" width=\"750\"></p><p>&nbsp;&nbsp;根据掘金小册上作者给予的canvas的简单画图流程，个人实践之后觉得需要把闭合路径这一步放置到最后，因为有些属性在路径闭合之后进行修改不起作用，例如lineCap属性。</p><p>&nbsp;&nbsp;&nbsp;自己总结的canvas步骤:<strong>开始路径 -&gt;确定画圆还是画弧-&gt;设置颜色-&gt;确定是描边还是填充-&gt;闭合路径</strong></p><p>&nbsp;&nbsp;下列步骤为canvas基本流程中出现的代码</p><p><br></p><p><strong>&nbsp;&nbsp;A.定义Canvas</strong></p><p>&nbsp;&nbsp;定义canvas直接在html上创建一个canvas标签，之后设置canvas宽高</p><p>&nbsp;&nbsp;&nbsp;html上通过属性定义</p><p>&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"35\" width=\"617\"></p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;js上通过canvas实例属性定义</p><p>&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\"></p><p>&nbsp;&nbsp;&nbsp;</p><p><span style=\"background-color: rgb(255, 255, 0); color: rgb(255, 104, 32);\">&nbsp;&nbsp;css属性定义​</span></p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;<img src=\"//:0\"></p><p>&nbsp;&nbsp;需要注意三种定义canvas宽高的方式，推荐使用html与js来定义属性，至于不推荐使用css来定义宽高的原因是因为当使用CSS来定义的时候，<strong>canvas相当于一张300*150的图片(canvas的默认尺寸),有可能产生拉伸变形的效果</strong></p><p><strong>&nbsp;&nbsp;B.获取实例</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;获取实例方法就是原生JS获取DOM的API，getElementById(args),querySelector都可以获取canvas实例</p><p><strong>&nbsp;&nbsp;C.初始化canvas上下文</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p><img src=\"//:0\" height=\"110\" width=\"656\"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用getContext来进行初始化canvas上下文环境，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;MDN上关于getContext的文档解释(一般只使用第一个参数较多，第二个参数可查阅MDN):</p><blockquote><img src=\"//:0\" height=\"340\" width=\"605\"></blockquote><p><br></p><p><br></p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D.确定是画弧、画方形、还是画线，再确定是描边或者填充图形，</strong></p><p><strong>&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp;运用API创造图形，注意有些API是方法有些是属性</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"1084\" width=\"662\"></p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;圆弧API详解：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"592\" width=\"726\"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;圆弧API需要注意的是度数计算是弧度，即360度对应2PI来计算</p><p><br></p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给予直线样式：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"306\" width=\"483\"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给予阴影样式:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"457\" width=\"509\"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置渐变：（创建渐变-&gt;设置渐变-&gt;产生颜色-&gt;用颜色进行填充）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"325\" width=\"491\"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"266\" width=\"427\"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图形转换</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"//:0\" height=\"374\" width=\"544\"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：角度仍然为弧度制 ，弧度=degree*(PI/180),缩放scale不止形状大小缩放，坐标也会缩放，看缩放效果的时候注意画布大小，可能缩放比例过大导致缩放结果在画布之外。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p><br></p>', '1');
INSERT INTO `tp_article` VALUES ('7', 'vuex 基础使用的各种姿势（1）Store、State、Getter', 'CarryOnHxy', '1550651965344', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>vuex 基础使用的各种姿势（1）Store、State、Getter</em></h1><h2><br></h2><p><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#comments\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">评论：0</a>&nbsp;<em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;<a href=\"http://www.ptbird.cn/vuex-use-some-env.html\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">阅读：212</a><em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;喜欢：0</p><blockquote>本篇文章仅适合基础回顾，不具备深度</blockquote><ul><li><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_1\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">一、vuex 的基本描述</a></li><li><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_2\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">二、Store 及基本使用</a></li><li><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_3\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">三、state</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_4\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">mapState</a></li><li><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_5\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">四、Getters</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_6\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">1、getter 的定义及基本使用</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_7\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">2、多个 getter 配合</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_8\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">3、getter 传参</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/vuex-use-some-env.html#menu_index_9\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">4、mapGetter</a></li></ul><h2>一、vuex 的基本描述</h2><blockquote>vue 的中文文档支持的足够好，不需要重复文档</blockquote><p>文档地址：<a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://vuex.vuejs.org/zh/</a></p><p>核心思想（流程）：</p><p><img src=\"https://vuex.vuejs.org/vuex.png\" alt=\"https://vuex.vuejs.org/vuex.png\"></p><p>如果熟悉&nbsp;<a href=\"https://facebook.github.io/flux/\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">Flux</a>&nbsp;架构，则对 vuex 的这套基本的流程体系也基本就能够理解，这里不不再重复。</p><p>相比于 Flux，vuex 对其进行了 vue 的适配，借助 vue 的&nbsp;<strong>细粒度响应机制</strong>（文档说的）进行高效的状态更新，基本上大型项目如果要进行状态管理，直接就是 vuex 就可以，而 React 系，则存在 Flux、Redux、MobX 等等。</p><p>有些时候官方规范化之后也有好处。</p><p>安装引入很简单：</p><pre class=\"ql-syntax\" spellcheck=\"false\">yarn add vuex\n\nimport Vuex from \'vuex\'\n\n</pre><h2>二、Store 及基本使用</h2><p>严格来说，Store 的概念并不是 vuex 的直接子集<strong>属性</strong>，每个 vuex 的核心就是 Store，也可以称之为仓库，而这个 Store 就是一个单一状态管理容器。</p><p>Store 中可以配置 State、getter、mutation 等属性，而Store 的属性涵盖了对一个数据的初始化、获取及更新操作。</p><p>Store 维护了一套响应式的状态存储机制，也就是当 Store 的数据发生变化是，会通知 Vue 组件，进行响应式的更新。</p><p>一个 Store 会有一些约定好的属性，因此定义一个 Store 的过程基本如下：</p><p>引入 Vue 及 Vuex，并启用 Vuex:</p><pre class=\"ql-syntax\" spellcheck=\"false\">import Vue from \'vue\';\nimport Vuex from \'vuex\';\n\nVue.use(Vuex);\n\n</pre><p>一定要确保&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">Vue.use(Vuex);</code>&nbsp;在&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">new Vuex.Store({})</code>&nbsp;之前调用， 否则你会收到这样一个错误：</p><p>[vuex] must call Vue.use(Vuex) before creating a store instance.</p><p>定义 Store 的 state：</p><pre class=\"ql-syntax\" spellcheck=\"false\">const state = {\n  count: 0\n}\n\n</pre><p>定义 Store 的 getters：（如果需要）</p><pre class=\"ql-syntax\" spellcheck=\"false\">const getters = {\n  getCount(state) {\n    return state.count;\n  }\n}\n\n</pre><p>这样可以不通过&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.$store.state.count</code>&nbsp;的形式访问，而是可以通过&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.$store.getters.getCount</code>&nbsp;的形式访问（当然还有更简洁方式），出了访问方式变动之外，可以在函数中进行一系列操作，然后在返回数据。</p><p>定义 Store 的 mutations:</p><pre class=\"ql-syntax\" spellcheck=\"false\">const mutations = {\n  increment(state){\n    state.count ++ ;\n  }\n}\n\n</pre><p>getters 是获取数据，而 mutations 则是显示的对数据进行更改。 Store 的 state 是不允许通过&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.$store.state.count = 2</code>&nbsp;的形式去修改的，必须显示的提交修改才能去执行修改。</p><p>提交修改的方式是&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.$store.commit(mutationName)</code>。</p><p>将 state、getters 以及 mutations 作为初始化内容传入&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">new Vuex.Store({})</code>:</p><pre class=\"ql-syntax\" spellcheck=\"false\">const store = new Vuex.Store({\n state,\n getters,\n mutations\n});\n\nexport default store;\n\n</pre><p>最后将 store 导出，然后在&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">new Vue({})</code>&nbsp;的地方引入，挂载到 store 属性下即可。</p><pre class=\"ql-syntax\" spellcheck=\"false\">import store from \'./store\';\n\nnew Vue({\n  el: \'#app\',\n  router,\n  store,\n  render: (c) =&gt; {return c(App)}\n});\n\n</pre><h2>三、state</h2><p>Vuex 是一个单一的状态树来管理状态，而 Store 则是Vuex 的存储仓库，每个 Store 中真实表示数据或者状态的则是 Store 的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">state</code>&nbsp;属性。</p><p>如果熟悉 React 则就无需强调什么是&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">state</code>&nbsp;了， 所有的数据初始化定义都应该在&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">state</code>&nbsp;中定义，并且获取数据也可以从 state 中取，只是无法直接去更改某个 state 的值。</p><p>比如在模板中读取某个 state 的值的方式：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;p&gt;count is: {{this.$store.state.count}}&lt;/p&gt;\n\nconsole.log(this.$store.state.count)\n\n</pre><p>而在如果你没有使用 getters 的话，一般也会推荐将 state 的值初始化给组件computed 的某个属性，能够简化很多&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.$store.state.xxx</code>&nbsp;的代码。</p><p>比如我将<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">state.count</code>&nbsp;赋值给&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">computed</code>&nbsp;中的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">count</code>：</p><pre class=\"ql-syntax\" spellcheck=\"false\">    computed: {\n      count() {\n        return this.$store.state.count\n      }\n    },\n\n</pre><p>这样在模板中我可以直接使用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">count</code>:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;p&gt;count is: {{count}}&lt;/p&gt;\n\n</pre><h3>mapState</h3><blockquote>我本人不觉得 mapState 有什么特别大的帮助，只是在开发上可能少写点代码而已</blockquote><p>使用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">mapState</code>&nbsp;需要首先从 vuex 中引入</p><pre class=\"ql-syntax\" spellcheck=\"false\">  import {mapState} from \'vuex\';\n\n</pre><p>即使每次初始化 computed，也需要写大量的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.$store.state.xx</code>&nbsp;因此 vuex 暴露一个&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">mapState</code>&nbsp;的属性，用来边界开发，尤其是将 state 的值初始化给 computed 的时候：</p><pre class=\"ql-syntax\" spellcheck=\"false\">  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state =&gt; state.count,\n\n    // 传字符串参数 \'count\' 等同于 `state =&gt; state.count`\n    countAlias: \'count\',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n\n</pre><p>上面 computed 的定义中，直接是运行了&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">mapState</code>&nbsp;方法， 然后参数是一个对象：</p><ul><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">count: state =&gt; state.count</code>：定义一个 computed:count，通过一个函数传入 state 参数，并返回 state.count</li><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">countAlias: \'count\',</code>&nbsp;直接对 state.count 进行重命名</li><li><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">countPlusLocalState (state) { return state.count + this.loca.... }</code>&nbsp;如果需要获取 本组件的一些状态，则必须使用常规函数的形式，并且将&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">state</code>&nbsp;传入函数，其中可以通过&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.xxx</code>&nbsp;获取局部状态。</li></ul><p>如果想直接用 state 的名称，可以直接给&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">mapState</code>&nbsp;传一个数组：</p><pre class=\"ql-syntax\" spellcheck=\"false\">computed: mapState([\n  // 映射 this.count 为 store.state.count\n  \'count\'\n])\n\n</pre><p>而如果本地也有 computed 数据，然后也需要 state 初始化一些本地数据，借助 mapState 实现的话，需要进行对象展开符，当然，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">mapState</code>&nbsp;该怎么用还是怎么用，与上面一样。</p><pre class=\"ql-syntax\" spellcheck=\"false\">computed: {\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}\n\n</pre><h2>四、Getters</h2><p>getters 只是为了更加方便的获取数据，比如一个 count state，如果不同的组件需要不同结果的 count，则一般都是由业务组件去做这个事情，而 store 也可以把这个事情给做掉。</p><p>举例：我需要在每个 state.count 的值前面，在加上一个 state.num，组合成一个新的值给多个组件使用。</p><p>如果组件完成这个事情，则需要有组件去实现，（包括金钱、时间的格式化，内容过滤等操作），而通过 getter 则可以提供统一的访问形式。</p><h3>1、getter 的定义及基本使用</h3><p>getter 的定义也很简单，定义某个属性，方法中形参是 state：</p><pre class=\"ql-syntax\" spellcheck=\"false\">  getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }\n\n</pre><p>通过传入的 state 参数，可以访问当前 store 的状态，进行一系列的判断过滤等。</p><h3>2、多个 getter 配合</h3><p>getter 也可以结合其他的 getter 一起使用，getter 定义的第二个参数可以是其他 getter：</p><pre class=\"ql-syntax\" spellcheck=\"false\">getters: {\n  doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n  },\n  doneTodosCount: (state, getters) =&gt; {\n    return getters.doneTodos.length\n  }\n}\n\n</pre><p>上面的例子中，首先我已经定义完了&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">doneTodos</code>&nbsp;这个 getter，但是比如我还需要获取完成的 todo 的数量，如果我还是使用 state 的话，我还需要写一遍遍历判断最后计数。</p><p>而我直接使用当前 getters.doneTodos.length 就不需要再去写那些代码了。</p><h3>3、getter 传参</h3><p>除此之外，还可以通过方法访问 getters，所谓的方法访问无非就是传递参数，来进行不同的预期处理：</p><pre class=\"ql-syntax\" spellcheck=\"false\">getters: {\n  getTodoById: (state) =&gt; (id) =&gt; {\n    return state.todos.find(todo =&gt; todo.id === id)\n  }\n}\n\n</pre><p>比如上面的 getters 支持通过 id 查找 todo，并且返回。</p><p>当定义好之后，就能够直接通过下面的方式查找需要的 todo：</p><pre class=\"ql-syntax\" spellcheck=\"false\">this.$store.getters.getTodoById(2) // -&gt; { id: 2, text: \'...\', done: false }\n\n</pre><p>而这种定义方式，无非就是一个科里化，没有什么新奇的玩意儿。</p><h3>4、mapGetter</h3><p>mapGetter 的使用需要首先引入&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">import { mapGetters } from \'vuex\'</code></p><p>mapGetter 如同&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">mapState</code>&nbsp;一样，没什么特别新奇的功能，也是一种辅助作用，写代码比较轻松，必须要写那么多的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">this.$store.getters.name</code></p><p>而使用的形式也非常类似于&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">mapState</code>：</p><pre class=\"ql-syntax\" spellcheck=\"false\">  computed: mapGetter({\n    // 箭头函数可使代码更简练\n    count: getters=&gt; getters.getCount,\n\n    // 传字符串参数 \'count\' 等同于 `getters=&gt; getters.getCount`\n    countAlias: \'getCount\',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (getters) {\n      return getters.getCount+ this.localCount\n    }\n  })\n}\n</pre><p><br></p>', '1');
INSERT INTO `tp_article` VALUES ('9', 'vue-router 配合 webpack 进行路由懒加载', 'CarryOnHxy', '1550652112240', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>vue-router 配合 webpack 进行路由懒加载</em></h1><h2><br></h2><p><a href=\"http://www.ptbird.cn/vue-router-lazy-loading-with-webpack.html#comments\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">评论：0</a>&nbsp;<em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;<a href=\"http://www.ptbird.cn/vue-router-lazy-loading-with-webpack.html\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">阅读：253</a><em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;喜欢：0</p><ul><li><a href=\"http://www.ptbird.cn/vue-router-lazy-loading-with-webpack.html#menu_index_1\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">一、描述</a></li><li><a href=\"http://www.ptbird.cn/vue-router-lazy-loading-with-webpack.html#menu_index_2\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">二、传统的 router 配置</a></li><li><a href=\"http://www.ptbird.cn/vue-router-lazy-loading-with-webpack.html#menu_index_3\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">二、路由懒加载 router 配置及作用</a></li><li><a href=\"http://www.ptbird.cn/vue-router-lazy-loading-with-webpack.html#menu_index_4\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">四、问题</a></li><li><a href=\"http://www.ptbird.cn/vue-router-lazy-loading-with-webpack.html#menu_index_5\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">五、demo 代码</a></li></ul><h2>一、描述</h2><p>vue &amp; webpack 的开发模式如果网站内容特别多，会导致 SPA 打出来的包的大小非常的大，经常超过 1M，因此一般会使用 webpack 的 code spliting 把代码分割成不同的 chunk。</p><p>按需加载 vue 支持异步组件的方式，因此 vue-router 提供了<strong>路由懒加载</strong>，可以在路由切换之后再去请求相关路由组件的资源，从而在某种程度上减少 bundle 的大小。</p><p>开发的脚手架是之前自己用 webpack4.x 配置的，可以在&nbsp;<a href=\"https://github.com/postbird/webpack4.x-vue-develop\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://github.com/postbird/webpack4.x-vue-develop</a>&nbsp;直接 clone 项目，然后：</p><pre class=\"ql-syntax\" spellcheck=\"false\">yarn install \nyarn start\n\n</pre><p>即可，不对 webpack 配置 vue 基本的开发环境做过多的阐述，不过目前的脚手架没有配置 router，需要自己配置。文章结束之后我会发一个本篇文章的 demo 到 github，可以直接运行</p><h2>二、传统的 router 配置</h2><p>直接上配置文件，通过&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">import</code>&nbsp;的方式引入组件，然后在 routes 中配置相关的路由信息，很基本的配置了：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import VueRouter from \'vue-router\';\n\nimport Index from \'../components/Index.vue\';\nimport Hello from \'../components/Hello.vue\';\nimport List from \'../components/List.vue\';\n\n\nconst routes = [\n  { path: \'/\', alias:\'/index\', component: Index },\n  { path: \'/hello\', component: Hello },\n  { path: \'/list\', component: List }\n];\n\nconst router = new VueRouter({ routes });\n\nexport default router;\n\n</pre><p>在模板中使用的时候也是如此，正常使用：</p><pre class=\"ql-syntax\" spellcheck=\"false\">    &lt;ul&gt;\n      &lt;li&gt;&lt;router-link to=\"/index\"&gt;Index&lt;/router-link&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;router-link to=\"/hello\"&gt;Hello&lt;/router-link&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;router-link to=\"/list\"&gt;List&lt;/router-link&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n\n</pre><p>最终的结果：</p><p>进入首页，将 main.bundle.js 完整的请求下来</p><p><img src=\"http://static.ptbird.cn/usr/uploads/2019/01/4185221614.jpg\" alt=\"1.jpg\"></p><p>切换其他路由后不会进行新的资源请求</p><p><img src=\"http://static.ptbird.cn/usr/uploads/2019/01/2235142986.gif\" alt=\"GIF.gif\"></p><h2>二、路由懒加载 router 配置及作用</h2><p>路由懒加载其实依赖于 webpack 的 code-spliting 以及 vue 的异步组件，关于 vue 的异步组件可以看：</p><ul><li><a href=\"https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6</a></li></ul><p>而异步组依赖动态 import，react 也有这个思想：<a href=\"https://reactjs.org/docs/code-splitting.html#import\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://reactjs.org/docs/code-splitting.html#import</a></p><p>vue-router 结合动态 import 及 异步组件的支持，通过将之前配置的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">import Index from \'../components/Index.vue\';</code>&nbsp;这种直接 import 的方式改变成&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">const Index = () =&gt; import(\'../components/Index.vue\');</code>&nbsp;这种能够被 webpack 识别并自动分割代码的组件。</p><p>因此 router 的配置变化如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">\n\nimport VueRouter from \'vue-router\';\n\nconst Index  = () =&gt; import(\'../components/Index.vue\');\nconst Hello = () =&gt; import( \'../components/Hello.vue\');\nconst List = () =&gt; import( \'../components/List.vue\');\n\n\nconst routes = [\n  { path: \'/\', alias:\'/index\', component: Index },\n  { path: \'/hello\', component: Hello },\n  { path: \'/list\', component: List }\n];\n\nconst router = new VueRouter({ routes });\n\nexport default router;\n\n</pre><p>除了 router 的配置会发生变化之外，如果使用了 babel，则 webpack 进行代码分割的时候需要依赖 babel 的一个插件&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">@babel/babel-plugin-syntax-dynamic-import</code>，文档地址：<a href=\"https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/</a></p><p>因此需要更改 webpack 中 babel 的配置，因为我是直接写在了&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">webpack.dev.config.js</code>，所以还是直接更新 webpack.dev.config.js：(prod.config.js 没更改，因为只是 demo)</p><pre class=\"ql-syntax\" spellcheck=\"false\">      {\n        test: /\\.(js)$/,\n        exclude: /(node_modules)/,\n        use:{\n          loader: \'babel-loader\',\n          options: {\n            presets: [\'@babel/preset-env\'],\n            plugins: [\'@babel/transform-runtime\', \"@babel/plugin-syntax-dynamic-import\"]\n          }\n        }\n      },\n\n</pre><p>首次进入,可以发现除了加载了一个 bundle.js 之外，还加载了一个&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">2.bundle.js</code>：</p><p><img src=\"http://static.ptbird.cn/usr/uploads/2019/01/351634679.jpg\" alt=\"2.jpg\"></p><p>当切换路由的时候，会发现每次切换的路由都多请求了一个&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">x.bundle.js</code>，而里面的内容则是路由组件的内容</p><p><img src=\"http://static.ptbird.cn/usr/uploads/2019/01/1172089650.gif\" alt=\"2222.gif\"></p><p><img src=\"http://static.ptbird.cn/usr/uploads/2019/01/1259336833.jpg\" alt=\"3.jpg\"></p><h2>四、问题</h2><p>两次对比其实有一个很明显的问题可以发现，路由懒加载之前，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">main.bundle.js</code>&nbsp;的大小是&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">183kb</code>，而路由懒加载之后，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">main.bundle.js</code>&nbsp;还是&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">183kb</code>，根本没有减少。</p><p>第二个问题是，在&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">main.bundle.js</code>&nbsp;都相同的情况下，使用路由懒加载后，每次都会多请求&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">1.4kb</code>&nbsp;的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">x.bundle.js</code>，这个特别尴尬。路由懒加载之后 bundle 不但没减少，反而多请求了好几 kb 的资源 好几个网络请求。</p><p>因为我的每个组件内容都很少，基本都是下面特别简单的内容：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n</pre><p>所以分离出去懒加载后，对整体的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">main.bundle.js</code>&nbsp;没有什么大的影响，大小未发生变化，每个 bundle 单独打包，webpack 又会注入自己的规范代码，导致多注入了很多代码（见上面截图）。</p><p>所以&nbsp;路由懒加载&nbsp;一定要看实际的情况，并不是使用了就一定有好处，有些极端情况下，反而会带来更多的压力。</p><h2>五、demo 代码</h2><p>请注意，文章的 demo 在&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">dev/router-lzay-loading</code>&nbsp;分支：</p><ul><li><a href=\"https://github.com/postbird/webpack4.x-build-vue-0-1-demo/tree/dev/router-lazy-loading\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://github.com/postbird/webpack4.x-build-vue-0-1-demo/tree/dev/router-lazy-loading</a></li></ul><p><br></p>', '1');
INSERT INTO `tp_article` VALUES ('10', '使用 React Hook 实现一个简单的 Todo', 'CarryOnHxy', '1550652295504', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>使用 React Hook 实现一个简单的 Todo</em></h1><h2><br></h2><p><a href=\"http://www.ptbird.cn/react-hook-todo-list.html#comments\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">评论：0</a>&nbsp;<em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;<a href=\"http://www.ptbird.cn/react-hook-todo-list.html\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">阅读：1168</a><em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;喜欢：0</p><h2>一、需求</h2><p>需要使用一个 React 实现一个 Todo List，这个简单的要死。</p><p>但是现在使用 Hook 来实现两个基本组件，而使用的 Hook 则是&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useState</code>。</p><p>github 地址：</p><ul><li><a href=\"https://github.com/postbird/todo-by-react-hook\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://github.com/postbird/todo-by-react-hook</a></li></ul><p>效果：</p><p><img src=\"http://static.ptbird.cn/usr/uploads/2018/12/1835149717.gif\" alt=\"GIF.gif\"></p><h2>二、App.js</h2><pre class=\"ql-syntax\" spellcheck=\"false\">import React, { Component } from \'react\';\nimport \'./App.css\';\nimport Form from \'./components/Form\';\nimport Item from \'./components/Item\';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      list:[{\n        computed: false,\n        val: \'初始化内容\'\n      }]\n    }\n  }\n  addHandle = (val) =&gt; {\n    this.setState({\n      list: [{computed: false,val}].concat(this.state.list)\n    });\n  }\n  render() {\n    return (\n      &lt;div className=\"App\"&gt;\n        &lt;Form add={this.addHandle}/&gt;\n        &lt;div className={\'list\'}&gt;\n          {\n            this.state.list.map((item, index) =&gt; {\n              return &lt;Item item={item} key={index} &gt;&lt;/Item&gt;\n            })\n          }\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default App;\n\n</pre><h2>二、Form 组件</h2><h3>Form.jsx</h3><p>这个是表单组件主要是完成输入和添加操作</p><pre class=\"ql-syntax\" spellcheck=\"false\">import \'./Form.css\';\n\nimport React, {useState} from \'react\';\n\n function Form(props) {\n  const [value, setValue] = useState(\'\');\n  const clickHandle = () =&gt; {\n    if (typeof props.add === \'function\' &amp;&amp; value.length &gt; 0) {\n      props.add(value);\n    }\n    setValue(\'\');\n  }\n  return (\n    &lt;div className=\"wrapper\"&gt;\n      &lt;input\n       value={value} \n       onChange={(ev) =&gt;{setValue(ev.target.value)}} \n       className=\"input\"\n       placeholder={\'todo..\'}\n      /&gt;\n      &lt;button className={\'btn\'} onClick={clickHandle}&gt;\n        Add\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n\nexport default Form;\n\n</pre><h3>Form.css</h3><pre class=\"ql-syntax\" spellcheck=\"false\">.wrapper {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.input{\n  width:80%;\n  padding: 5px;\n  height: 50px;\n  color: #000000;\n  font-size: 30px;\n}\n.btn{\n  height: 50px;\n  width: 20%;\n  background-color: #cccccc;\n  border:0;\n  font-size: 30px;\n}\n\n</pre><h2>三、Item 组件</h2><p>承载每个 Item 主要操作是完成和未完成状态变更</p><h3>Item.jsx</h3><pre class=\"ql-syntax\" spellcheck=\"false\">import React, {useState} from \'react\';\nimport \'./Item.css\';\n\n\nfunction Item(props) {\n  const [computed, setCompoted] = useState(props.item.computed);\n  const clickHandle = () =&gt; {\n    setCompoted(!computed);\n  };\n  return (\n    &lt;div className=\"item\" onClick={clickHandle}&gt;\n      {\n        !computed \n        ? &lt;p &gt;{props.item.val}&lt;/p&gt; \n        : &lt;s &gt;{props.item.val}&lt;/s&gt;\n      }\n    &lt;/div&gt;\n  );\n}\n\nexport default Item;\n\n</pre><h3>Item.css</h3><pre class=\"ql-syntax\" spellcheck=\"false\">.item {\n  width: 100%;\n  margin-top: 20px;\n  border: 1px solid #ff5000;\n  padding: 10px;\n  font-weight: 500;\n  font-size: 20px;\n}\n\n</pre><p><br></p><p><br></p>', '2');
INSERT INTO `tp_article` VALUES ('11', 'React Hook 内置 API 指南', 'CarryOnHxy', '1550652353312', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>React Hook 内置 API 指南</em></h1><h2><br></h2><p><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#comments\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">评论：0</a>&nbsp;<em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;<a href=\"http://www.ptbird.cn/react-hook-api-refrence.html\" target=\"_blank\" style=\"color: rgb(153, 153, 153); background-color: transparent;\">阅读：1061</a><em style=\"color: rgb(102, 102, 102);\">·</em>&nbsp;喜欢：2</p><ul><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_1\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">一、API 列表</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_2\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">二、基本 Hook</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_3\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">1、useState</a></li><li class=\"ql-indent-2\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_4\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">1、通过 function 更新 state</a></li><li class=\"ql-indent-2\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_5\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">2、注意：</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_6\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">3、延迟初始化</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_7\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">2、useEffect</a></li><li class=\"ql-indent-2\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_8\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">1、清理 effect</a></li><li class=\"ql-indent-2\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_9\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">2、effect 的时间</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_10\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">3、有条件的触发 effect</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_11\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">3、useContext</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_12\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">二、附加 Hook</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_13\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">1、useReducer</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_14\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">1、延迟初始化</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_15\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">2、useCallback</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_16\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">注意:</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_17\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">3、useMemo</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_18\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">注意:</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_19\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">4、useRef</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_20\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">5、useImperativeMethods</a></li><li><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_21\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">6、useLayoutEffect</a></li><li class=\"ql-indent-1\"><a href=\"http://www.ptbird.cn/react-hook-api-refrence.html#menu_index_22\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">TIP</a></li></ul><h2>一、API 列表</h2><p>React 内置的 Hook 如下：</p><ul><li>基础 Hook：</li><li class=\"ql-indent-1\">useState</li><li class=\"ql-indent-1\">useEffect</li><li class=\"ql-indent-1\">useContext</li><li>其他 Hook：</li><li class=\"ql-indent-1\">useReducer</li><li class=\"ql-indent-1\">useCallback</li><li class=\"ql-indent-1\">useMemo</li><li class=\"ql-indent-1\">useRef</li><li class=\"ql-indent-1\">useImperativeMehtods</li><li class=\"ql-indent-1\">useLayoutEffect</li></ul><h2>二、基本 Hook</h2><h3>1、useState</h3><pre class=\"ql-syntax\" spellcheck=\"false\">const [state, setState] = useState(initialState);\n\n</pre><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useState</code>&nbsp;返回一个状态值变量，以及一个更新这个状态的方法。</p><p>在初始渲染期间，返回的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">state</code>&nbsp;与作为第一个参数&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">initialState</code>&nbsp;传递的值相同。</p><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">setState</code>&nbsp;函数用于更新 state，它接受一个新的状态值，并将组件的 re-render 排入队列中。</p><pre class=\"ql-syntax\" spellcheck=\"false\">setState(newState);\n\n</pre><p>在后面的 re-render 期间，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useState</code>&nbsp;返回的第一个值将始终是应用更新之后的最新 state。</p><h4>1、通过 function 更新 state</h4><p>如果使用先前 state 计算新的 state，则可以将一个函数传递个 setState。该函数将接收之前的值，并返回更新的值。下面是一个使用两种形式的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">setState</code>&nbsp;的计数器组件的示例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">function Counter({initialCount}) {\n  const [count, setCount] = useState(initialCount);\n  return (\n    &lt;&gt;\n      Count: {count}\n      &lt;button onClick={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;\n      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;+&lt;/button&gt;\n      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;-&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n\n</pre><p>“+” 和 “-” 按钮使用 function 形式，因为更新的值基于先前的值，但 “重置” 按钮使用普通的形式，因为它总是将计数设置回0。</p><h4>2、注意：</h4><p>和类组件中的&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">setState</code>&nbsp;方法不同，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useState</code>&nbsp;不会自动合并更新对象。你可以通过将函数 updater 表单与对象扩展语法组合来复制此行为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">setState(prevState =&gt; {\n  // 也可以使用 Object.assign\n  return {...prevState, ...updatedValues};\n});\n\n</pre><p>另一个选项是使用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useReducer</code>，它更适合管理包含多个子值的 state 对象。</p><h4>3、延迟初始化</h4><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">initialState</code>&nbsp;参数是初始渲染期间使用的 state，在之后的 render 中，它就被忽略了。如果初始 state 是昂贵计算的结果，则可以改为提供函数，这个函数仅在初始 render 的时候执行：</p><pre class=\"ql-syntax\" spellcheck=\"false\">const [state, setState] = useState(() =&gt; {\n  const initialState = someExpensiveComputation(props);\n  return initialState;\n});\n\n</pre><h3>2、useEffect</h3><pre class=\"ql-syntax\" spellcheck=\"false\">useEffect(didUpdate);\n\n</pre><p>接受一个 function 作为参数，这个 function 可能是副作用的方法。</p><p>函数组件的主体内部不允许使用 mutation、订阅、timer、日志记录以及其他的副作用（也就是在 React 的渲染阶段）。这样做会导致 UI 中的错误和不一致性混乱。</p><p>React function 组件中，应当使用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;来完成这些事情。传递给&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;的函数将在渲染提交到屏幕后运行。将 effect 视为从 React 的纯粹 function 进入命令式的一种 escape hatch (逃生舱)。</p><p>默认情况下，effect 在每次完成渲染后都会执行，但是可以选择仅在某些值发生更改时触发它。</p><h4>1、清理 effect</h4><p>通常，effect 会创建在组件离开屏幕之前需要清理的资源，比如订阅或者计时器ID。为此，传递给&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;可能会返回一个清理函数：</p><pre class=\"ql-syntax\" spellcheck=\"false\">useEffect(() =&gt; {\n  const subscription = props.source.subscribe();\n  return () =&gt; {\n    // 清理订阅\n    subscription.unsubscribe();\n  };\n});\n\n</pre><p>clear function 在从 UI 中删除组件之后就执行，以防止内存泄露。此外，如果组件多次 rende（通常都会多次 render），则在执行下一个 effect 之前会清楚之前的 effect。在上面的示例中，每次 render 都会创建一个新的订阅。</p><h4>2、effect 的时间</h4><p>与&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">componentDidMount</code>&nbsp;和&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">componentDidUpdate</code>&nbsp;不同，在延迟事件期间，传递给&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;的函数在布局和绘制后触发。这使得它适用于许多常见的副作用，例如设置订阅和事件处理程序，因为大多数类型的工作不应该阻止浏览器更新屏幕。</p><p>但是，并不是所有的 effect 都可以延迟。例如，用户可见的 DOM 突变必须在下一次绘制之间同步触发，以便用户不会感觉到视觉上的不一致。（区别在概念上类似于被动事件侦听器和活动事件侦听器），对于这些类型的 effect，React 提供了一个名为&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useLayoutEffect</code>&nbsp;的 附加 Hook。它与&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;具有相同的签名，仅在触发时有所不同。</p><p>虽然&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;延迟到浏览器绘制完成之后，但是它保证在任何新的 render 之前触发，在开始新的更新之前，React 将始终刷新先前 render 的 effect。</p><h4>3、有条件的触发 effect</h4><p>effect 的默认行为是在每次完成 render 后触发 effect。这样如果其中一个 输入发生变化，会始终创建 effect。</p><p>但是，在某些情况下，这可能是过度的，比如上面的订阅示例，应该仅在 prop 发生更改的时候，我们才会进行创建新的订阅。</p><p>要实现此功能，需要将第二个参数传递给&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>，它是 effect 所依赖的值数组：</p><pre class=\"ql-syntax\" spellcheck=\"false\">useEffect(\n  () =&gt; {\n    const subscription = props.source.subscribe();\n    return () =&gt; {\n      subscription.unsubscribe();\n    };\n  },\n  [props.source],\n);\n\n</pre><p>上面代码中，只有在&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">props.source</code>&nbsp;更改的时候才会重新创建订阅。</p><p>传入一个空数组&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">[]</code>&nbsp;告诉 React 你的 effect 不依赖组件中的任何值，因此这个 effect 只能在 mount 的时候执行，而在 unmount 的时候清理，不会再更新的时候执行。</p><p><strong>注意：</strong></p><p>输入数组不作为参数传递给 effect 函数，但从概念上讲，这就是它们所代表的内容：effect 函数中引用的每个值也应该出现在输入数组中。在未来，一个足够先进的表一起可以自动创建这个数组。</p><h3>3、useContext</h3><pre class=\"ql-syntax\" spellcheck=\"false\">const context = useContext(Context);\n\n</pre><p>接受上下文对象（从&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">React.createContext</code>&nbsp;返回的值）并且返回当前的上下文值，由给定上下文的最近上下文提供程序给出。</p><p>当提供程序更新时，这个 Hook 将使用最新的上下文值触发 re-render。</p><h2>二、附加 Hook</h2><p>附件 Hook 实际上是上面的基础 Hook 的一种变体，也可以用于特定的边缘情况。（React 建议不作为先学习的内容）</p><h3>1、useReducer</h3><pre class=\"ql-syntax\" spellcheck=\"false\">const [state, dispatch] = useReducer(reducer, initialState);\n\n</pre><p>这是&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useState</code>&nbsp;的替代方案，接收类型为&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">(state, action) =&gt; newState</code>&nbsp;的 reducer，并返回与 dispatch 方法配对的当前 state。（如果熟悉 Redux，你已经知道这是如果工作的）</p><p>下面是之前的计数器示例使用 reducer 重写的：</p><pre class=\"ql-syntax\" spellcheck=\"false\">const initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \'reset\':\n      return initialState;\n    case \'increment\':\n      return {count: state.count + 1};\n    case \'decrement\':\n      return {count: state.count - 1};\n    default:\n      // A reducer must always return a valid state.\n      // Alternatively you can throw an error if an invalid action is dispatched.\n      return state;\n  }\n}\n\nfunction Counter({initialCount}) {\n  const [state, dispatch] = useReducer(reducer, {count: initialCount});\n  return (\n    &lt;&gt;\n      Count: {state.count}\n      &lt;button onClick={() =&gt; dispatch({type: \'reset\'})}&gt;\n        Reset\n      &lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({type: \'increment\'})}&gt;+&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({type: \'decrement\'})}&gt;-&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n\n</pre><h4>1、延迟初始化</h4><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useReducer</code>&nbsp;接收可选的第三个参数是&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">initialAction</code>。如果提供了， 则在初始化渲染期间应用初始操作。这对于计算包含通过 props 传递的值的初始 state 非常有用：</p><pre class=\"ql-syntax\" spellcheck=\"false\">const initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \'reset\':\n      return {count: action.payload};\n    case \'increment\':\n      return {count: state.count + 1};\n    case \'decrement\':\n      return {count: state.count - 1};\n    default:\n      // A reducer must always return a valid state.\n      // Alternatively you can throw an error if an invalid action is dispatched.\n      return state;\n  }\n}\n\nfunction Counter({initialCount}) {\n  const [state, dispatch] = useReducer(\n    reducer,\n    initialState,\n    {type: \'reset\', payload: initialCount},\n  );\n\n  return (\n    &lt;&gt;\n      Count: {state.count}\n      &lt;button\n        onClick={() =&gt; dispatch({type: \'reset\', payload: initialCount})}&gt;\n        Reset\n      &lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({type: \'increment\'})}&gt;+&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({type: \'decrement\'})}&gt;-&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n\n</pre><p>如果涉及多个子值的复杂状态逻辑时，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useReducer</code>&nbsp;通常优于&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useState</code>，它还允许优化触发深度更新的组件的性能，因为可以传递调度而不是回调。更多内容可以看 react 的博客：<a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down</a></p><h3>2、useCallback</h3><pre class=\"ql-syntax\" spellcheck=\"false\">const memoizedCallback = useCallback(\n  () =&gt; {\n    doSomething(a, b);\n  },\n  [a, b],\n);\n\n</pre><p>返回一个&nbsp;<a href=\"https://en.wikipedia.org/wiki/Memoization\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">memoized</a>&nbsp;回调</p><p>传递内联回调和一组输入。&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useCallback</code>&nbsp;将返回一个有记忆的版本，这个版本仅在其中一个输入发生更改的时候才会发生变动。当将回调传递给依赖于引用相等性的优化子组件以防止不必要的 render ，比如（shouldComponentUpdate）的时候，这非常有用。</p><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useCallback(fn, inputs)</code>&nbsp;等效于&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useMemo(() =&gt; fn, inputs)</code>.</p><h4>注意:</h4><p>输入数组不作为参数传递给回调。从概念上讲：回调内引用的每个值也应该出现在 inputs 数组中，将来，一个足够先进的编译器可以自动创建这个数组。</p><h3>3、useMemo</h3><pre class=\"ql-syntax\" spellcheck=\"false\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\n\n</pre><p>返回一个有记忆的值。</p><p>传递 “创建” 功能和输入数组。&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useMemo</code>&nbsp;只会在其中一个输入发生更改的时候重新计算 memoized 值，这个优化有助于避免在每个 render 时进行昂贵的计算。</p><p>如果没有提供数组，则只要将函数实例作为第一个参数传递，就会计算新值。（使用内联函数，在每个 render 上）</p><h4>注意:</h4><p>输入数组不作为参数传递给回调。从概念上讲：回调内引用的每个值也应该出现在 inputs 数组中，将来，一个足够先进的编译器可以自动创建这个数组。</p><h3>4、useRef</h3><pre class=\"ql-syntax\" spellcheck=\"false\">const refContainer = useRef(initialValue);\n\n</pre><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useRef</code>&nbsp;返回一个可变的 ref 对象，其 current 属性被初始化为传递的参数&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">initialValue</code>。返回的对象将持续整个组件的生命周期。</p><p>常见的使用场景是强制访问子组件：</p><pre class=\"ql-syntax\" spellcheck=\"false\">function TextInputWithFocusButton() {\n  const inputEl = useRef(null);\n  const onButtonClick = () =&gt; {\n    // `current` points to the mounted text input element\n    inputEl.current.focus();\n  };\n  return (\n    &lt;&gt;\n      &lt;input ref={inputEl} type=\"text\" /&gt;\n      &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n\n</pre><p>请注意&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useRef()</code>&nbsp;比直接使用 ref 属性有用。保持任何可变值的方式类似于在类中使用实例字段的方法。（<a href=\"https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables\" target=\"_blank\" style=\"color: rgb(46, 171, 253); background-color: transparent;\">https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables</a>）</p><h3>5、useImperativeMethods</h3><pre class=\"ql-syntax\" spellcheck=\"false\">useImperativeMethods(ref, createInstance, [inputs])\n\n</pre><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useImperativeMethods</code>&nbsp;自定义使用 ref 时公开给父组件的示例值。与往常一样，在大多数情况下应避免使用 refs 的命令式代码。</p><p><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useImperativeMethods</code>&nbsp;与&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">forwardRef</code>&nbsp;一起使用：</p><pre class=\"ql-syntax\" spellcheck=\"false\">function FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeMethods(ref, () =&gt; ({\n    focus: () =&gt; {\n      inputRef.current.focus();\n    }\n  }));\n  return &lt;input ref={inputRef} ... /&gt;;\n}\nFancyInput = forwardRef(FancyInput);\n\n</pre><p>在上面的示例中，渲染&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">&lt;FancyInput ref={fancyInputRef} /&gt;&nbsp;</code>的父组件能够调用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">fancyInputRef.current.focus()</code></p><h3>6、useLayoutEffect</h3><p>签名和&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;相同，但所有的 DOM 突变后同步触发。使用它从 DOM 读取布局并同步重新渲染。在浏览器有机会绘制之前，将在&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useLayoutEffect</code>&nbsp;内部计划的更新将同步刷新。</p><p>应当尽可能的选择标准&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useEffect</code>&nbsp;来避免阻塞 UI 的更新。</p><h4>TIP</h4><p>如果你正在从 class 组件迁移代码，则&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useLayoutEffect</code>&nbsp;会在与&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">componentDidMount</code>&nbsp;和&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">componentDidUpdate</code>相同的阶段触发，因此如果不确定 Hook 需要哪种 Hook，使用&nbsp;<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">useLayoutEffect</code>&nbsp;风险是最小的。</p>', '2');
INSERT INTO `tp_article` VALUES ('12', 'Omi框架学习之旅 - 组件 及原理说明', 'CarryOnHxy', '1550652422272', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>Omi框架学习之旅 - 组件 及原理说明</em></h1><p><span style=\"color: rgb(0, 51, 102);\">hello world demo看完后其实基本的写法就会了。</span></p><p><span style=\"color: rgb(0, 51, 102);\">但是omi中的组件是神马鬼？其实我也不知道组件是啥。</span></p><p><span style=\"color: rgb(0, 51, 102);\">百度百科是这么说的：&nbsp;是对数据和方法的简单封装。es6中，一个类其实也可以做到对方法和数据的封装。然后new出来的实例共享原型上的方法，至于属性最好不要共享啦，</span></p><p><span style=\"color: rgb(0, 51, 102);\">如果需要共享，自己写静态属性，或者Object.assign到原型上去。这里有点扯远了。</span></p><p><span style=\"color: rgb(51, 153, 102);\">我的理解是一个组件就是一个类，至于组件嵌套，其实就是父类和子类，无非就是挂载到对应的属性下</span></p><p><span style=\"color: rgb(51, 153, 102);\">（父类会主动帮我们自动的new 子类(被嵌套的组件)的实例并且添加些相应的属性，然后和父组件中render中的html合并一下）。</span></p><p>接下来看看一个组件的demo。</p><p>老规矩：先上demo代码, 然后提出问题, 之后解答问题, 最后源码说明。</p><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><pre class=\"ql-syntax\" spellcheck=\"false\">        // 组件嵌套抽出List\n        class List extends Omi.Component {\n            constructor(data) {\n                super(data);\n            }\n\n            render() {\n                return `\n                    &lt;ul&gt;\n                        {{#items}}\n                            &lt;li&gt;\n                                {{.}}\n                            &lt;/li&gt;\n                        {{/items}}\n                    &lt;/ul&gt;\n                `;\n            }\n        };\n\n        Omi.makeHTML(\'List2\', List);    // 使用Omi.makeHTML把List类制作成可以声明式的标签List2，在render方法中就能直接使用该标签\n\n        class Todo extends Omi.Component {\n            constructor(data) {\n                super(data);\n                this.data.length = this.data.items.length;    // 给data添加个length属性\n                this.listData = {items: this.data.items};    // listData属性名和下面的data=\"listData\"中的listData对应\n            }\n\n            style() {\n                return `\n                    h3 {\n                        color: red;\n                    }\n                    button {\n                        color: green;\n                    }\n                `;\n            }\n\n            handleChange(target, evt) {\n                this.data.text = target.value;    \n                console.log(this.data.text);\n            }\n\n            add(evt) {\n                evt.preventDefault();\n                this.instance_list.data.items.push(this.data.text);    // this.instance_list这个其实就是下面name=\"instance_list\"的instance_list(他其实就是List类的实例)\n                this.data.length = this.listData.items.length;    // 跟新属性\n                this.data.text = \'\';\n                this.update();\n                console.log(this.data);\n                console.log(this.instance_list.data);    // this.instance_list中的data属性其实是一级浅拷贝this.listData这个的\n                console.log(this.listData);\n            }\n\n            render() {\n                return `\n                    &lt;div&gt;\n                        &lt;h3&gt;TODO&lt;/h3&gt;\n                        &lt;List2 name=\"instance_list\" data=\"listData\"&gt;&lt;/List2&gt;    &lt;!--name 对应List2标签对应的List类的实例,  data的listData属性其实浅拷贝到instance_list实例的data上--&gt;\n                        &lt;form&gt;\n                            &lt;input type=\"text\" onchange=\"handleChange(this, event)\" value=\"{{text}}\" /&gt;\n                            &lt;button onclick=\"add(event)\"&gt;add #{{length}}&lt;/button&gt;\n                        &lt;/form&gt;\n                    &lt;/div&gt;\n                `;\n            }\n        };\n\n        var todo = new Todo({\n            items: [1, 2],\n            text: \'\'\n        });\n        Omi.render(todo, \'#app\');\n        console.log(todo.instance_list);\n</pre><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><p>先看看omi中文文档的说明：</p><p>额，因为demo源码是我自己敲的，有稍微变化，所以说明就挑重要的说明,</p><p>&nbsp;<span style=\"color: rgb(51, 153, 102);\">通过makeHTML方法把组件制作成可以在render中使用的标签。使用Omi.makeHTML(\'List2\', List);即可</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;在父组件上定义listData属性用来传递给子组件。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;在render方法中使用List2组件。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;其中name方法可以让你在代码里通过this快速方法到该组件的实例。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;data=\"listData\"可以让你把this.listData传递给子组件。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;需要注意的是，父组件的this.listData会被通过Object.assign浅拷贝到子组件。&nbsp;</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;这样做的目的主要是希望以后DOM的变更都尽量修改子组件自身的data，然后再调用其update方法，而不是去更改父组件的listData。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;</span><span style=\"color: rgb(0, 0, 0);\">文档地址</span><span style=\"color: rgb(51, 153, 102);\">：</span><a href=\"https://alloyteam.github.io/omi/website/docs-cn.html#\" target=\"_blank\" style=\"color: rgb(51, 153, 102);\">https://alloyteam.github.io/omi/website/docs-cn.html#</a></p><p>&nbsp;</p><p><span style=\"color: rgb(255, 0, 255);\">接下来说说这个demo的疑问和疑问的说明：</span></p><p><span style=\"color: rgb(255, 0, 0);\">疑问1：</span></p><p><span style=\"color: rgb(255, 0, 0);\">Omi.makeHTML(\'List2\', List);这个语句是干啥的，参数类型分别是啥？</span></p><p><span style=\"color: rgb(0, 0, 0);\">答：&nbsp;</span><span style=\"color: rgb(51, 153, 102);\">这是Omi对象的一个静态方法,作用是把类制作成可以声明式的标签。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;这么说似乎有点难懂。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;简单的说就是一个名字对应一个构造函数,也就是键值对。是存放在Omi.componetConstructor这个对象上的。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;并且也把标签名存到Omi.customTags这个数组中。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;源码感受：&nbsp;</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">    Omi.makeHTML= function(name, ctor) {    // name: 组件标签名, ctor: 构造函数也就是类啦\n        Omi.componetConstructor[name] = ctor;    // 把标签名对应类放到componetConstructor对象中去\n        Omi.customTags.push(name);    // 自定义标签\n    };\n</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(51, 153, 102);\">那这么做的目的就是就是当我们使用omi.render的时候，他会自动帮我们new&nbsp;List实例然后合并父组件中的html。(这里当然是循环遍历每个孩子标签啦)。继续往下看。</span></p><p>&nbsp;</p><p><span style=\"color: rgb(255, 0, 0);\">疑问2：</span></p><p><span style=\"color: rgb(255, 0, 0);\">我的List2标签制作好了，该怎么用到其他组件中去呢？</span></p><p><span style=\"color: rgb(255, 0, 0);\">标签是使用单标签还是双标签呢？</span></p><p><span style=\"color: rgb(0, 0, 0);\">答：</span><span style=\"color: rgb(51, 153, 102);\">可以在任意一个组件类的render方法中使用制作好的List2标签。可以如下使用：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;List2 name=\"instance_list\" data=\"listData\"&gt;&lt;/List2&gt;    双标签\n//或者\n&lt;List2 name=\"instance_list\" data=\"listData\" /&gt;    单标签\n</pre><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(51, 153, 102);\">&nbsp;这里面的&nbsp;name=\"instance_list\" data=\"listData\" 又是神马鬼啊，其实是这样的</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;属性name对应的值instance_list其实就是 new List()的实例</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;属性data对应的值listData就是被一级浅拷贝到instance_list实例上的data上了。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;那么的话，我操作数据的话，可以操作instance_list上的data数据然后instance_list.update()即可（原作者推荐），其实我们也可以在父类上操作listData属性然后this.update()，数据就更新了。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;哇，这么牛逼，怎么做到的呢？继续往下看</span></p><p>&nbsp;</p><p><span style=\"color: rgb(255, 0, 0);\">&nbsp;疑问3：</span></p><p><span style=\"color: rgb(255, 0, 0);\">上面的&lt;List2 name=\"instance_list\" data=\"listData\"&gt;&lt;/List2&gt;这个标签里面的属性是不是涉及到组件通讯了啊？</span></p><p><span style=\"color: rgb(0, 0, 0);\">答：</span><span style=\"color: rgb(51, 153, 102);\">是的，组件通讯有4种，加上一个终极通讯模式（上帝模式），后续会讲解的。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;本demo的通讯其实通过List2标签上的data属性值listData来实现通讯的。</span></p>', '4');
INSERT INTO `tp_article` VALUES ('13', 'Omi框架学习之旅 - Hello World 及原理说明', 'CarryOnHxy', '1550652491600', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>Omi框架学习之旅 - Hello World 及原理说明</em></h1><p>学什么东西都从hello world开始, 我也不知道为啥。</p><p>恩，先上demo代码, 然后提出问题, 之后解答问题, 最后源码说明。</p><p>&nbsp;</p><p>hello world - demo:</p><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><pre class=\"ql-syntax\" spellcheck=\"false\">        class Hello extends Omi.Component {    // 1. Hello类先继承Component类\n            constructor(str, data) {    // 2. Hello类构造函数的参数和个数随便传,但是必须要有个数据对象data(其实可以是对象或者传undefined,因为其还有第二个参数,不传undefined的话,第二个参数就变成了第一个参数)\n                super(data);    //  3. es6和es5的继承还是有区别的,es6需要先得到父类的this实例，然后子类对其加工。Component父类其实可以接受2个参数的,这里就先接受data数据对象作为第一个参数\n                this.str = str;\n                console.log(this);\n            }\n\n            style() {    // 4. style方法其实是Hello类重写了Component类的style方法(其实父类的style方法也只是空函数)\n                return `\n                    h1 {\n                        color: red;\n                    }\n                `;\n            }\n\n            clickHandle(t, evt) {    // 5. Hello类的原型方法和Component类没关系哈\n                console.log(t, evt);\n            }\n\n            render() {    // 6. render方法也是Hello类重写了Component类的render方法\n                return `\n                    &lt;h1 onclick=\"clickHandle(this, event)\"&gt;aaa{{name}}&lt;/h1&gt;\n                `;\n            }\n        };\n\n        var hello = new Hello(\'str\', {name: \'hello world\'});    // 7. 创建Hello类的实例\n        Omi.render(hello, \'#app\');    // 8.让omi渲染(生成html和局部css和把内置事件和对应的实例clickHandle函数关联起来)\n</pre><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><p>&nbsp;先看看omi中文文档的说明：</p><p><span style=\"color: rgb(0, 128, 0);\">组件生成的HTML最终会插入到#app中。上面的例子展示了Omi的部分特性:</span></p><ul><li><span style=\"color: rgb(0, 128, 0);\">data传递: new Hello(data,..)的data可以直接提供给render方法里的模板</span></li><li><span style=\"color: rgb(0, 128, 0);\">局部CSS: h1只对render里的h1生效，不会污染外面的h1</span></li><li><span style=\"color: rgb(0, 128, 0);\">声明式事件绑定: onclick调用的就是组件内的handleClick，this可以拿到当前的DOM元素,还可以拿到当前的event</span></li><li><span style=\"color: rgb(0, 128, 0);\">文档地址：</span><a href=\"https://alloyteam.github.io/omi/website/docs-cn.html#\" target=\"_blank\" style=\"color: rgb(100, 102, 179);\">https://alloyteam.github.io/omi/website/docs-cn.html#</a></li></ul><p><span style=\"color: rgb(255, 0, 255);\">接下来说说这个demo的疑问和疑问的说明：</span></p><p><span style=\"color: rgb(255, 0, 0);\">疑问1：</span></p><p><span style=\"color: rgb(255, 0, 0);\">自己写的类一定要继承Omi.Component类吗?</span></p><p>答：<span style=\"color: rgb(51, 153, 102);\">废话,想用omi,你还不继承别人的属性和方法,怎么玩下去(当然牛逼的人可以自己写哈)。</span></p><p><span style=\"color: rgb(51, 153, 102);\">注: Component类是核心, 源码在component.js中,然后&nbsp;</span></p><p><span style=\"color: rgb(51, 153, 102);\">Omi.Component = Component; 把Component类挂载到Omi的Component对象上去了。</span></p><p>&nbsp;</p><p><span style=\"color: rgb(255, 0, 0);\">疑问2：</span></p><p><span style=\"color: rgb(255, 0, 0);\">super()方法中可以传什么数据类型的参数,和参数的个数?</span></p><p>答：<span style=\"color: rgb(51, 153, 102);\">Component构造函数可以接收2个参数。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;理论上可以有这几种传参的方式:</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传1个参数&nbsp;super()/super(undefined), super({}), super(\'str\'),&nbsp;super(true),&nbsp;super([]),&nbsp;super(null)</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传2个参数 super(data, 真值)</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;先说传1个参数会导致啥吧：</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传&nbsp;true, \'str\', [], null, 会使变量isReRendering则为true, {}, undefined/或者不传参数, 变量isReRendering则为false,然而isReRendering变量是if的条件会开了2个分支，</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理不同的逻辑。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;传2个参数会怎样啊：</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个参数可以任意类型的值：因为会和对象{server: false, ignoreStoreData: false}合并</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;感受下omi的源码：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><pre class=\"ql-syntax\" spellcheck=\"false\">constructor(data, option) {    // data: 数据data, option: 一般为对象\n        const componentOption = Object.assign({    // 和并option\n            server: false,    // 老版中的server属性\n            ignoreStoreData: false    // 忽略存储数据\n        }, option);\n        this._omi_ignoreStoreData = componentOption.ignoreStoreData;    // 是否忽略存储数据属性_omi_ignoreStoreData\n        //re render the server-side rendering html on the client-side\n        const type = Object.prototype.toString.call(data);    // data的数据类型\n        const isReRendering = type !== \'[object Object]\' &amp;&amp; type !== \'[object Undefined]\';    // 是否重新渲染\n        if (isReRendering) {\n            this.renderTo = typeof data === \"string\" ? document.querySelector(data) : data\n            this._hidden = this.renderTo.querySelector(\'.omi_scoped__hidden_data\')\n            this.id = this._hidden.dataset.omiId\n            this.data = JSON.parse(this._hidden.value)\n        } else {\n            this.data = data || {};    // 给实例添加 data属性\n            this._omi_server_rendering = componentOption.server;    // _omi_server_rendering属性\n            this.id = this._omi_server_rendering ? (1000000 + Omi.getInstanceId()) : Omi.getInstanceId();    // id属性\n        };\n        this.refs = {};\n        this.children = [];    // 每个实例的孩子\n        this.childrenData = [];    // 每个实例孩子的数据\n        this.HTML = null;    // 实例中render返回的字符串\n        this._addedItems = [];\n        Omi.instances[this.id] = this;    // Omi._instanceId 对应 Component类的每个实例(或者子类)\n        this.dataFirst = true;    \n\n        this._omi_scoped_attr =  Omi.STYLESCOPEDPREFIX + this.id;    // 实例的样式局部属性 omi_scoped_ + id\n        //this.BODY_ELEMENT = document.createElement(\'body\')\n        this._preCSS = null;    // 预设样式\n        this._omiGroupDataCounter = {}; \n        if (this._omi_server_rendering || isReRendering) {\n            this.install()\n            this._render(true)\n            this._childrenInstalled(this)\n            this.installed()\n        }\n    }\n</pre><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><p>&nbsp;</p><p><span style=\"color: rgb(255, 0, 0);\">&nbsp;疑问3：</span></p><p><span style=\"color: rgb(255, 0, 0);\">style()方法是干啥的？</span></p><p><span style=\"color: rgb(0, 0, 0);\">答：&nbsp;</span><span style=\"color: rgb(51, 153, 102);\">style方法返回一个css字符串,用来生成局部css的。style方法中可以写各种语句哈。只要返回css字符串即可。</span></p><p>&nbsp;</p><p><span style=\"color: rgb(255, 0, 0);\">&nbsp;疑问4：</span></p><p><span style=\"color: rgb(255, 0, 0);\">render()方法是干啥的？</span></p><p><span style=\"color: rgb(0, 0, 0);\">答：</span><span style=\"color: rgb(51, 153, 102);\">render方法返回一个html字符串，就是html组合好的标签啦。render方法中可以写各种语句哈。只要返回字符串即可。</span></p><p>&nbsp;</p><p><span style=\"color: rgb(255, 0, 0);\">疑问5：</span></p><p><span style=\"color: rgb(255, 0, 0);\">那omi是怎么帮我们生成局部css和html插入到指定的dom容器中呢。html内置的事件又是怎样对应起Hello类中clickHandle方法？</span></p><p><span style=\"color: rgb(0, 0, 0);\">答：</span><span style=\"color: rgb(51, 153, 102);\">这一切就得从Omi.render(hello, \'#app\'); 这个语句开始。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><pre class=\"ql-syntax\" spellcheck=\"false\">Omi.render = function(component , renderTo , incrementOrOption){    // 实例, 渲染到的dom, xx\n        component.renderTo = typeof renderTo === \"string\" ? document.querySelector(renderTo) : renderTo;    // 实例的renderTo属性\n        if (typeof incrementOrOption === \'boolean\') {\n            component._omi_increment = incrementOrOption;    // 实例的_omi_increment 属性(老版)\n        } else if (incrementOrOption) {    // 新增\n            component._omi_increment = incrementOrOption.increment;\n            component.$store = incrementOrOption.store;\n            if (component.$store) {\n                component.$store.instances.push(component);\n            };\n            component._omi_autoStoreToData = incrementOrOption.autoStoreToData;\n        };\n        component.install();    // Component类的install方法(被实例继承了)\n        component._render(true);    // Component类的_render方法(被实例继承了)\n        component._childrenInstalled(component);\n        component.installed();\n        return component;\n    }\n</pre><p><span style=\"color: rgb(100, 102, 179);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(51, 153, 102);\">render方法就omi上的一个静态方法,接收3个参数(实例, 渲染到的dom, xx), xx表示我也不清楚这个变量干啥的,以后肯定会知道的。</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;方法中的这个语句对于这个demo很重要component._render(true);接下来终点看看这个方法.</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(51, 153, 102);\">这个方法里面对于这个demo最重要的语句就是</span></p><p><span style=\"color: rgb(51, 153, 102);\">&nbsp;&nbsp;&nbsp;this._generateHTMLCSS(); // 生成 html 和 css， 怎么生成html和css呢，看如下代码</span></p>', '4');
INSERT INTO `tp_article` VALUES ('14', ' 微信小程序之授权登录的实现（button按钮）', 'CarryOnHxy', '1550652583336', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em> 微信小程序之授权登录的实现（button按钮）</em></h1><p>前言：由于微信官方修改了 getUserInfo、authorize 接口，无法弹出授权窗口，所以现在无法实现一进入微信小程序就弹出授权窗口，只能通过 button 去触发</p><p><br></p><p>1.实现思路</p><p>微信授权登录仅适用于使用微信用户信息的用户，如果自己的项目有完善的用户信息（一套式开发项目），可不使用微信用户信息；如果仅为微信小程序，则要授权、获取用户信息</p><p><br></p><p>自己写一个微信授权登录页面让用户实现点击的功能，也就是实现了通过 button 组件去触发 getUserInof 接口。在用户进入微&nbsp;</p><p>信小程序的时候，判断用户是否授权了，如果没有授权的话就显示下面“界面简介”的第一个图，让用户去执行授权的操作。如&nbsp;</p><p>果已经授权了，则直接跳过这个页面，进入首页。</p><p><br></p><p>2.界面简介</p><p><br></p><p><br></p><p>3.源码</p><p>authorize.html</p><p><br></p><p>&lt;view wx:if=\"{{canIUse}}\"&gt;</p><p>&nbsp;&nbsp;&lt;view class=\'header\'&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;image src=\'/images/wx_login.png\'&gt;&lt;/image&gt;</p><p>&nbsp;&nbsp;&lt;/view&gt;</p><p><br></p><p>&nbsp;&nbsp;&lt;view class=\'content\'&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;view&gt;申请获取以下权限&lt;/view&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;text&gt;获得你的公开信息(昵称，头像等)&lt;/text&gt;</p><p>&nbsp;&nbsp;&lt;/view&gt;</p><p><br></p><p>&nbsp;&nbsp;&lt;button class=\'bottom\' type=\'primary\' open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"bindGetUserInfo\"&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;授权登录</p><p>&nbsp;&nbsp;&lt;/button&gt;</p><p>&lt;/view&gt;</p><p><br></p><p>&lt;view wx:else&gt;请升级微信版本&lt;/view&gt;</p><p><br></p><p>authorize.wxss</p><p><br></p><p>.header {</p><p>&nbsp;&nbsp;margin: 90rpx 0 90rpx 50rpx;</p><p>&nbsp;&nbsp;text-align: center;</p><p>&nbsp;&nbsp;width: 650rpx;</p><p>&nbsp;&nbsp;height: 300rpx;</p><p>&nbsp;&nbsp;line-height: 450rpx;</p><p>}</p><p><br></p><p>.header image {</p><p>&nbsp;&nbsp;width: 200rpx;</p><p>&nbsp;&nbsp;height: 200rpx;</p><p>}</p><p><br></p><p>.content {</p><p>&nbsp;&nbsp;margin-left: 50rpx;</p><p>&nbsp;&nbsp;margin-bottom: 90rpx;</p><p>}</p><p><br></p><p>.content text {</p><p>&nbsp;&nbsp;display: block;</p><p>&nbsp;&nbsp;color: #9d9d9d;</p><p>&nbsp;&nbsp;margin-top: 40rpx;</p><p>}</p><p><br></p><p>.bottom {</p><p>&nbsp;&nbsp;border-radius: 80rpx;</p><p>&nbsp;&nbsp;margin: 70rpx 50rpx;</p><p>&nbsp;&nbsp;font-size: 35rpx;</p><p>}</p><p><br></p><p>authorize.json</p><p><br></p><p>{</p><p>&nbsp;&nbsp;\"navigationBarTitleText\": \"授权登录\"</p><p>}</p><p>1</p><p>2</p><p>3</p><p>authorize.js</p><p><br></p><p>const app = getApp();</p><p>Page({</p><p>&nbsp;&nbsp;data: {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//判断小程序的API，回调，参数，组件等是否在当前版本可用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;canIUse: wx.canIUse(\'button.open-type.getUserInfo\')</p><p>&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;onLoad: function () {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;var that = this;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;// 查看是否授权</p><p>&nbsp;&nbsp;&nbsp;&nbsp;wx.getSetting({</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: function (res) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (res.authSetting[\'scope.userInfo\']) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.getUserInfo({</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: function (res) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从数据库获取用户信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that.queryUsreInfo();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用户已经授权过</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.switchTab({</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url: \'/pages/index/index\'</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;})</p><p>&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;bindGetUserInfo: function (e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (e.detail.userInfo) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用户按了允许授权按钮</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var that = this;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//插入登录的用户的相关信息到数据库</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.request({</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url: app.globalData.urlPath + \'user/add\',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openid: getApp().globalData.openid,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nickName: e.detail.userInfo.nickName,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avatarUrl: e.detail.userInfo.avatarUrl,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;province:e.detail.userInfo.province,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city: e.detail.userInfo.city</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header: {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'content-type\': \'application/json\'</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: function (res) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从数据库获取用户信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that.queryUsreInfo();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"插入小程序登录用户信息成功！\");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//授权成功后，跳转进入小程序首页</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.switchTab({</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url: \'/pages/index/index\'&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} else {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用户按了拒绝按钮</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wx.showModal({</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:\'警告\',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content:\'您点击了拒绝授权，将无法进入小程序，请授权之后再进入!!!\',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showCancel:false,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confirmText:\'返回授权\',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:function(res){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (res.confirm) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\'用户点击了“返回授权”\')</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;//获取用户信息接口</p><p>&nbsp;&nbsp;queryUsreInfo: function () {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;wx.request({</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url: app.globalData.urlPath + \'user/userInfo\',</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openid: app.globalData.openid</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header: {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'content-type\': \'application/json\'</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: function (res) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(res.data);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getApp().globalData.userInfo = res.data;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;})；</p><p>&nbsp;&nbsp;},</p><p><br></p><p>})</p><p><br></p><p>代码的 wx.request 是小程序发起网络请求，用于用户与数据的交互。官网地址：https://developers.weixin.qq.com/miniprogram/dev/api/network-request.html&nbsp;</p><p>URL分析：app.globalData.urlPath（全局url；例如：https://www.baidu.com）&nbsp;</p><p>user/userInfo(接口具体地址)</p><p><br></p><p>小程序源码地址：https://github.com/cuigeg/wxchat.git</p><p>---------------------&nbsp;</p><p>作者：醉卧码场君莫笑&nbsp;</p><p>来源：CSDN&nbsp;</p><p>原文：https://blog.csdn.net/woqianduo/article/details/81395257&nbsp;</p><p>版权声明：本文为博主原创文章，转载请附上博文链接！</p>', '5');
INSERT INTO `tp_article` VALUES ('15', '微信小程序概念篇', 'CarryOnHxy', '1550652645256', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>微信小程序概念篇</em></h1><blockquote>整理的概念，全是概念没啥实际用途，但是能让你和别人说起小程序的时候更加懂它的从无到有，从0到1</blockquote><h2>什么是微信小程序</h2><p>微信小程序简称小程序，英文名Mini Program，也被称为微信应用号，不同于微信订阅号或公众号，微信小程序被赋予了应用程序的能力，它是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用；也体现了“用完即走”的理念，用户不再需要关心是否安装太多应用的问题。</p><p>应用将无处不在，随时随地可用，无需卸载</p><h2>小程序发展时间轴</h2><p>2016年1月9日，腾讯公司启动了微信小程序产品的研发，提出应用号的概念</p><p>2016年9月22日，微信公众平台对外发送小程序内测邀请，内测名额200个</p><p>2016年11月3日，微信小程序对外公测，开发完成后可以提交审核，但公测期间不能发布</p><p>2016年12月28日，张小龙在微信公开课中解答外界对微信小程序的几大疑惑，包括没有应用商店、没有推送消息等</p><p>2016年12月30日，微信公众平台对外公告，上线的微信小程序最多可生成10000个带参数的二维码</p><p>2017年1月9日，微信小程序正式上线</p><p>2017年3月27日，微信小程序开放了个人账号申请，从此以后，不是企业也能开发小程序</p><p>2017年3月28日，微信小程序开放了蓝牙、卡卷、获知访问场景、共享微信通讯录等功能，并支持JS ES6新语法</p><p>2017年4月17日，微信小程序代码包的大小限制从1MB提升到2MB，开发了第三方平台开发小程序的功能，开放了数据分析接口</p><p>2017年4月20日，微信小程序对所有公众号都开放了关联小程序的功能</p><p>2017年4月25日，微信小程序开放了公众号推送文章可插入小程序的功能</p><p>2017年5月19日，微信小程序可支持蓝牙</p><p>2017年6月21日，微信小程序开放了打开另一个小程序的功能</p><p>2017年7月11日，微信小程序添加了富文本支持</p><p>....</p><h2>微信小程序能否取代APP</h2><p>这个标题老生常谈了，但是还是要说下，原生APP一般要同时开发IOS和Android两版，而小程序只需要做一版，这是小程序最大的优势，从这个角度看，小程序是“跨平台”的，在现阶段，小程序的开发效率低于APP，小程序独立出了一个封闭的生态，缺乏成熟的组件，统计、绘图组件，以前的echarts都无法使用，想要取代APP还要很长的路要走</p><h2>最新小程序框架</h2><p>mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。</p><p>Taro 是由京东 - 凹凸实验室打造的一套遵循 React 语法规范的多端统一开发框架，使用 Taro，我们可以只书写一套代码，通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App、快应用等）运行的代码</p><h2>微信小程序带来的机会</h2><p>微信小程序给很多想做程序员的人员提供了机会，因为它的门槛很低，不需要太难的技术，同时细心观察不难发现，在招聘网站上面已经有小程序工程师的岗位出现，微信小游戏的上线更新吸引一批HTML5游戏工程师的加入</p>', '5');
INSERT INTO `tp_article` VALUES ('16', 'angular学习', 'CarryOnHxy', '1550652705551', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>angular学习</em></h1><p>安装angular脚手架</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">npm&nbsp;install -g&nbsp;@angular/cli\n</pre><p>安装成功后，会多出来一个ng命令，查看是否安装成功</p><pre class=\"ql-syntax\" spellcheck=\"false\">ng&nbsp;--version\n</pre><p>常用命令</p><pre class=\"ql-syntax\" spellcheck=\"false\">ng new 项目名    // 新建Angular项目\nng build -prod  // 生产环境编译\nng serve        // 启动开发服务器\n</pre><blockquote>如果安装出错</blockquote><p>先删除原有安装</p><pre class=\"ql-syntax\" spellcheck=\"false\">npm uninstall -g @angular/cli\nnpm cache clean\nnpm install -g @angular/cli\n</pre><p><br></p>', '3');
INSERT INTO `tp_article` VALUES ('17', '广州吃货旅游攻略，错过就太可惜了！', 'CarryOnHxy', '1550652756720', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>广州吃货旅游攻略，错过就太可惜了！</em></h1><p class=\"ql-align-justify\">众所周知，广州是中国最发达的城市之一，同时广州也是一个值得一去的旅游城市，那么广州有哪些不错的旅游景点和小吃呢？如果你只知道去看广州塔，那你就真的是白来广州。现在就随小编一起来看一下吧!</p><p class=\"ql-align-justify\"><br></p><p><img src=\"http://t12.baidu.com/it/u=935948003,694955924&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=391&amp;s=FD10C219565B7FCE3A915AD40300C0A4\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p><img src=\"http://t11.baidu.com/it/u=4213576381,3651638491&amp;fm=173&amp;app=25&amp;f=JPEG?w=450&amp;h=356&amp;s=0094783343EECCEB185584D70100C0A3\" width=\"450px\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">第一天：石室圣心大教堂——沙面——陈家祠——上下九步行街</p><p><img src=\"http://t11.baidu.com/it/u=1229154628,406284816&amp;fm=173&amp;app=25&amp;f=JPEG?w=450&amp;h=565&amp;s=40986C3356165FEDA2D1B5C90300A0B3\" width=\"450px\"></p><p class=\"ql-align-justify\"><br></p><p><img src=\"http://t11.baidu.com/it/u=1528036684,448562843&amp;fm=173&amp;app=25&amp;f=JPEG?w=450&amp;h=499&amp;s=40106C33536F4EAD31C53CCB0300A0B0\" width=\"450px\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">第二天：越秀公园——纪念堂——北京路步行街——珠江夜游</p><p><img src=\"http://t11.baidu.com/it/u=262377583,2806506992&amp;fm=173&amp;app=25&amp;f=JPEG?w=450&amp;h=655&amp;s=4A20BD0B1A174BEB1A1598CE0300B0A0\" width=\"450px\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">第三天：中山大学——红砖厂创意园——海心沙广场——广州塔</p><p><img src=\"http://t12.baidu.com/it/u=3673559675,131677743&amp;fm=173&amp;app=25&amp;f=JPEG?w=450&amp;h=652&amp;s=4088F51B129777E9069C81C6030050A3\" width=\"450px\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">第四天：白云山</p><p><img src=\"http://t10.baidu.com/it/u=3016642683,1633479131&amp;fm=173&amp;app=25&amp;f=JPEG?w=450&amp;h=447&amp;s=6D92E51B514A4EEC18F0ADD3030080A3\" width=\"450px\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">美食攻略：</p><p><img src=\"http://t10.baidu.com/it/u=602917413,1575393940&amp;fm=173&amp;app=25&amp;f=JPEG?w=450&amp;h=615&amp;s=C110E43341CEDCE840C99DD10300D031\" width=\"450px\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">以上是小编介绍的关于广州吃到撑的旅游攻略，不仅可以欣赏广州的风采还能吃到地道的广州小吃，想去玩的赶紧收藏下。大家是否还有其他推荐，欢迎留言！</p><p><br></p>', '7');
INSERT INTO `tp_article` VALUES ('18', '前端测试', 'CarryOnHxy', '1550673017084', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>前端测试</em></h1><h1>前端测试</h1>', '4');
INSERT INTO `tp_article` VALUES ('19', '前端测试！！！！', 'CarryOnHxy', '1550673778348', '0', 'http://static.ptbird.cn/usr/uploads/2019/01/2875704279.jpg', '0', '<h1><em>前端测试！！！！</em></h1><h1>前端测试</h1><p><br></p><p><br></p><p><br></p>', '1');

-- ----------------------------
-- Table structure for tp_categrory
-- ----------------------------
DROP TABLE IF EXISTS `tp_categrory`;
CREATE TABLE `tp_categrory` (
  `id` tinyint(3) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_categrory
-- ----------------------------
INSERT INTO `tp_categrory` VALUES ('1', 'Vue');
INSERT INTO `tp_categrory` VALUES ('2', 'Recact');
INSERT INTO `tp_categrory` VALUES ('3', 'Angular');
INSERT INTO `tp_categrory` VALUES ('4', 'Omi');
INSERT INTO `tp_categrory` VALUES ('5', '微信小程序');
INSERT INTO `tp_categrory` VALUES ('6', '电脑技术');
INSERT INTO `tp_categrory` VALUES ('7', '其他');

-- ----------------------------
-- Table structure for tp_department
-- ----------------------------
DROP TABLE IF EXISTS `tp_department`;
CREATE TABLE `tp_department` (
  `id` smallint(5) NOT NULL AUTO_INCREMENT,
  `depart_name` varchar(30) DEFAULT NULL,
  `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '1正常2禁用',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_department
-- ----------------------------
INSERT INTO `tp_department` VALUES ('10', '技术部', '1');
INSERT INTO `tp_department` VALUES ('9', '市场部', '1');
INSERT INTO `tp_department` VALUES ('3', '销售部', '1');
INSERT INTO `tp_department` VALUES ('4', '业务部', '1');
INSERT INTO `tp_department` VALUES ('5', '人事部', '1');
INSERT INTO `tp_department` VALUES ('6', '财务部', '1');
INSERT INTO `tp_department` VALUES ('7', '企划部', '2');
INSERT INTO `tp_department` VALUES ('13', '行政部', '1');
INSERT INTO `tp_department` VALUES ('12', '管理部', '2');
INSERT INTO `tp_department` VALUES ('14', '广告部', '1');
INSERT INTO `tp_department` VALUES ('15', '测试', '0');

-- ----------------------------
-- Table structure for tp_employee
-- ----------------------------
DROP TABLE IF EXISTS `tp_employee`;
CREATE TABLE `tp_employee` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '职位编号',
  `depart_id` smallint(5) unsigned NOT NULL COMMENT '部门编号',
  `leader_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '直属领导编号',
  `role_id` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '角色编号',
  `position_id` smallint(5) unsigned NOT NULL COMMENT '职位编号',
  `user_code` varchar(20) NOT NULL COMMENT '员工账号',
  `real_name` varchar(20) NOT NULL COMMENT '员工姓名',
  `user_pwd` char(32) NOT NULL COMMENT '密码登录',
  `user_img` varchar(255) DEFAULT '/uploads/2018081819dee1bf7bc93772c6e133ff820f00ec.jpg' COMMENT '用户头像',
  `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态1正常2禁用',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_employee
-- ----------------------------
INSERT INTO `tp_employee` VALUES ('1', '10', '8', '13', '6', 'vvyng11', 'vvyng112', 'e10adc3949ba59abbe56e057f20f883e', '/uploads/20180818\\09fe6368b8ea8192ad28c420dd5b9316.jpg', '1');
INSERT INTO `tp_employee` VALUES ('9', '10', '8', '2', '7', 'zqs43511', '张青山', '0f0201f583a90d5c64e73a8e8ce3ba9c', '/uploads/2018081819dee1bf7bc93772c6e133ff820f00ec.jpg', '1');
INSERT INTO `tp_employee` VALUES ('3', '5', '1', '6', '3', '人事001', 'HR1', 'e10adc3949ba59abbe56e057f20f883e', '', '1');
INSERT INTO `tp_employee` VALUES ('5', '10', '8', '2', '6', 'vvyng', '甘泳红', 'e10adc3949ba59abbe56e057f20f883e', '/uploads/20180906\\7ffbbb3b799f039e0cd6c6a334d55d40.jpg', '1');
INSERT INTO `tp_employee` VALUES ('6', '13', '1', '4', '8', 'ganyh', 'vvyng', 'e10adc3949ba59abbe56e057f20f883e', '', '1');
INSERT INTO `tp_employee` VALUES ('7', '7', '5', '6', '11', 'qihua001', '企划主管', 'e10adc3949ba59abbe56e057f20f883e', '', '1');
INSERT INTO `tp_employee` VALUES ('8', '10', '1', '1', '7', 'admin', '张三', '21232f297a57a5a743894a0e4a801fc3', '/uploads/20180906\\252f2a8b3ee39d4bc8e477b705a1fcac.jpg', '1');
INSERT INTO `tp_employee` VALUES ('11', '10', '9', '13', '22', '111', '111', '698d51a19d8a121ce581499d7b701668', '/uploads/20180907/c2d786c6197b7f870f5e5880571bbd8c.jpg', '1');

-- ----------------------------
-- Table structure for tp_position
-- ----------------------------
DROP TABLE IF EXISTS `tp_position`;
CREATE TABLE `tp_position` (
  `id` smallint(5) NOT NULL AUTO_INCREMENT COMMENT '职位编号',
  `depart_id` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '部门编号',
  `position_name` varchar(30) NOT NULL COMMENT '职位名称',
  `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态1启用2禁用',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_position
-- ----------------------------
INSERT INTO `tp_position` VALUES ('2', '3', '销售主管', '1');
INSERT INTO `tp_position` VALUES ('3', '5', '人事主管', '1');
INSERT INTO `tp_position` VALUES ('22', '10', '普通开发', '1');
INSERT INTO `tp_position` VALUES ('5', '3', '销售专员', '2');
INSERT INTO `tp_position` VALUES ('6', '10', 'web前端工程师', '1');
INSERT INTO `tp_position` VALUES ('7', '10', 'PHP后台工程师', '1');
INSERT INTO `tp_position` VALUES ('8', '13', '行政专员', '1');
INSERT INTO `tp_position` VALUES ('9', '13', '行政主管', '1');
INSERT INTO `tp_position` VALUES ('10', '7', '企划专员', '1');
INSERT INTO `tp_position` VALUES ('11', '7', '企划主管', '1');
INSERT INTO `tp_position` VALUES ('23', '10', '普通开发', '1');

-- ----------------------------
-- Table structure for tp_roles
-- ----------------------------
DROP TABLE IF EXISTS `tp_roles`;
CREATE TABLE `tp_roles` (
  `id` smallint(5) NOT NULL AUTO_INCREMENT COMMENT '角色编号',
  `role_name` varchar(30) NOT NULL COMMENT '角色名称',
  `role_rules` text COMMENT '角色权限',
  `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态1正常2禁用',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_roles
-- ----------------------------
INSERT INTO `tp_roles` VALUES ('1', '超级管理员', null, '1');
INSERT INTO `tp_roles` VALUES ('2', '技术总监', '1,2,10,11,15,19', '1');
INSERT INTO `tp_roles` VALUES ('4', '行政主管', '10,11,15,19,12,13,14,16,17,18,20,21,22', '1');
INSERT INTO `tp_roles` VALUES ('5', '市场主管', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,44', '1');
INSERT INTO `tp_roles` VALUES ('6', '销售主管', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22', '1');
INSERT INTO `tp_roles` VALUES ('7', '部门主管', '10,11,12,13,14,15,16,17,18,19,20,21,22', '1');
INSERT INTO `tp_roles` VALUES ('13', '普通开发', '10,11,15,19', '1');

-- ----------------------------
-- Table structure for tp_rules
-- ----------------------------
DROP TABLE IF EXISTS `tp_rules`;
CREATE TABLE `tp_rules` (
  `id` smallint(5) NOT NULL AUTO_INCREMENT COMMENT '权限编号',
  `pid` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '上级权限编号',
  `rule_name` varchar(30) NOT NULL COMMENT '权限名称',
  `rule_address` varchar(30) DEFAULT NULL COMMENT '权限地址',
  `rule_icon` varchar(30) DEFAULT NULL COMMENT '权限图标',
  `is_menu` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '是否左侧菜单中显示0不显示1显示',
  `sort` tinyint(3) unsigned NOT NULL COMMENT '排序',
  `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态1正常2禁用',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=48 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_rules
-- ----------------------------
INSERT INTO `tp_rules` VALUES ('1', '0', '系统设置', '', 'cog', '1', '1', '1');
INSERT INTO `tp_rules` VALUES ('3', '1', '权限添加', 'rule/add', '', '0', '2', '1');
INSERT INTO `tp_rules` VALUES ('4', '1', '权限删除', 'rule/delete', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('5', '1', '权限修改', 'rule/edit', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('6', '1', '角色管理', 'role/index', '', '1', '2', '1');
INSERT INTO `tp_rules` VALUES ('7', '1', '角色添加', 'role/add', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('8', '1', '角色删除', 'role/delete', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('9', '1', '角色修改', 'role/edit', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('10', '0', '人员管理', '', 'users', '1', '1', '1');
INSERT INTO `tp_rules` VALUES ('11', '10', '部门管理', 'department/index', '', '1', '1', '1');
INSERT INTO `tp_rules` VALUES ('15', '10', '职位管理', 'position/index', '', '1', '1', '1');
INSERT INTO `tp_rules` VALUES ('19', '10', '员工管理', 'employee/index', '', '1', '1', '1');
INSERT INTO `tp_rules` VALUES ('2', '1', '权限管理', 'rule/index', null, '1', '2', '1');
INSERT INTO `tp_rules` VALUES ('12', '10', '部门添加', 'department/add', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('13', '10', '部门修改', 'department/edit', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('14', '10', '部门删除', 'department/delete', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('16', '10', '职位添加', 'position/add', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('17', '10', '职位修改', 'position/edit', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('18', '10', '职位删除', 'position/delete', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('20', '10', '员工添加', 'employee/add', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('21', '10', '员工修改', 'employee/edit', '', '2', '2', '1');
INSERT INTO `tp_rules` VALUES ('22', '10', '员工删除', 'employee/delete', '', '2', '2', '1');

-- ----------------------------
-- Table structure for tp_user
-- ----------------------------
DROP TABLE IF EXISTS `tp_user`;
CREATE TABLE `tp_user` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL,
  `password` varchar(32) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_user
-- ----------------------------
INSERT INTO `tp_user` VALUES ('1', 'admin', '21232f297a57a5a743894a0e4a801fc3');

-- ----------------------------
-- Table structure for tp_video
-- ----------------------------
DROP TABLE IF EXISTS `tp_video`;
CREATE TABLE `tp_video` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `src` varchar(255) DEFAULT '',
  `title` varchar(255) DEFAULT '',
  `timestamp` bigint(13) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_video
-- ----------------------------
INSERT INTO `tp_video` VALUES ('18', 'http://v.cen.ce.cn/video/2019-1-18/20191181547778069495_114.mp4', '前端测试！！！', '1550673828548');
INSERT INTO `tp_video` VALUES ('10', 'http://v.cen.ce.cn/video/2019-1-29/20191291548752387655_114.mp4', '独家！巴基斯坦朋友们的新春祝福', '1550494961579');
INSERT INTO `tp_video` VALUES ('17', 'http://v.cen.ce.cn/video/2019-1-18/20191181547777715264_114.mp4', '前端测试视频', '1550673060948');
INSERT INTO `tp_video` VALUES ('11', 'http://v.cen.ce.cn/video/2019-1-24/20191241548328328032_37.mp4', '巴商：中国武术在巴基斯坦有很大市场', '1550494961579');
INSERT INTO `tp_video` VALUES ('12', 'http://v.cen.ce.cn/video/2019-1-31/20191311548930790001_132.mp4', '如何制作手工装饰毯', '1546395652000');
INSERT INTO `tp_video` VALUES ('15', 'http://v.cen.ce.cn/video/2019-1-18/20191181547778069495_114.mp4', '中经网探秘清华博士生的一天', '1546395652000');
INSERT INTO `tp_video` VALUES ('16', 'http://v.cen.ce.cn/video/2019-1-18/20191181547777715264_114.mp4', 'As a woman！世界那么大，女子可以做什么？', '1550494961579');

-- ----------------------------
-- Table structure for tp_weekly
-- ----------------------------
DROP TABLE IF EXISTS `tp_weekly`;
CREATE TABLE `tp_weekly` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '周志编号',
  `user_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '提交人编号',
  `depart_id` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '部门编号',
  `position_id` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '职位编号',
  `leader_id` int(5) unsigned NOT NULL DEFAULT '0' COMMENT '直属领导编号',
  `title` varchar(50) NOT NULL COMMENT '周志标题',
  `content` text NOT NULL COMMENT '周志内容',
  `add_time` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '提交时间',
  `approval_user` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '审批人编号',
  `approval_time` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '审批时间',
  `approval_content` varchar(255) NOT NULL COMMENT '审批内容',
  `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态0待审批1已审批2驳回',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tp_weekly
-- ----------------------------
